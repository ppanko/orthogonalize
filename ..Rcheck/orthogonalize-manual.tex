\nonstopmode{}
\documentclass[a4paper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8,latin1]{inputenc}
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `orthogonalize'}}
\par\bigskip{\large \today}
\end{center}
\begin{description}
\raggedright{}
\item[Type]\AsIs{Package}
\item[Title]\AsIs{Simple covariate residualization}
\item[Version]\AsIs{1.1}
\item[Date]\AsIs{2019-2-21}
\item[Author]\AsIs{Pavel Panko}
\item[Maintainer]\AsIs{Pavel Panko }\email{pavel.panko@ttu.edu}\AsIs{}
\item[Description]\AsIs{Residualize an outcome variable based on a predictor set.}
\item[License]\AsIs{GPL (>=3)}
\item[Imports]\AsIs{Rcpp (>= 0.12.18), RcppArmadillo}
\item[LinkingTo]\AsIs{Rcpp, RcppArmadillo}
\item[RoxygenNote]\AsIs{6.1.1}
\item[Suggests]\AsIs{testthat, devtools}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{orthogonalize}{Residualize covariates. }{orthogonalize}
%
\begin{Description}\relax
Provides functionality to create residual "orthogonal" scores via linear 
regression more quickly and conveniently than \code{lm}. 
\end{Description}
%
\begin{Usage}
\begin{verbatim}
orthogonalize(formula, data, intercept = FALSE, group = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{formula}] 
a \code{"character"} vector or an object of class \code{"formula"} specifying the `response`
variable to be residualized and a set of `terms` to residualize the
`response` on, using linear regression. 

\item[\code{data}] 
a \code{"data.frame"} object containing the data set.  

\item[\code{intercept}] 
a \code{"logical"} value indicating whether or not to 
add the intercept term estimated by the regression model to the
extracted residuals in the return object. Defaults to FALSE.

\item[\code{group}] 
an optional \code{"numeric"} or \code{"factor"} vector that
specifies subsets of the data for within-group residualization. Can
also be a "character" value specifying the column name of the
grouping variable if it is attached to the \code{"data.frame"}
provided to the \code{data} argument. Defaults to NULL.  

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This function is based on symbolic model
representation via a formula, just like \code{lm}. The
formula accepts a single `response` separated by a \code{"\textasciitilde{}"} from a set of `terms`, which are
themselves separated by a \code{+}. The formula is evaluated and the
relevant data are provided to a OLS estimator where the `response`
is regressed on the `terms`. The residuals of the `response` are 
retained and returned by the function; the returned residuals of the
`response` variable can be said to be "orthogonalized" in respect to the `terms`. 
If \code{group} is provided, the within-group `response` residuals
are returned. 
\end{Details}
%
\begin{Value}
a numeric vector of the same length as the provided \code{data}. 
\end{Value}
%
\begin{Author}\relax
Pavel Panko
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
## Load the data:
data(iris)

## Orthogonalize "Petal.Width":
Petal.Width.Prime <- orthogonalize(
	formula   = "Petal.Width ~ Petal.Length + Sepal.Length", 
	data      = iris, 
	intercept = TRUE
)

## Orthgonalize "Petal.Width" within "Species:
Petal.Width.Prime <- orthogonalize(
	formula = "Petal.Width ~ .", 
	data    = iris, 
	group   = "Species" 
)
\end{ExampleCode}
\end{Examples}
\printindex{}
\end{document}
